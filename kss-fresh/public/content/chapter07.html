<!-- Chapter 7: SPARQL - RDF 질의 언어 (실전 마스터 코스) -->

<div class="chapter-header">
    <h1>Chapter 7. SPARQL - 지식 그래프의 열쇠</h1>
    <div class="chapter-subtitle">데이터에서 지혜로, 질의에서 통찰로</div>
    <div class="chapter-quote">
        "SPARQL은 단순한 질의 언어가 아니라, 지식을 탐험하고 발견하는 도구입니다." <br>
        <span class="quote-author">- Eric Prud'hommeaux, SPARQL 표준 공동 저자</span>
    </div>
</div>

<div class="reading-time">
    <i class="fas fa-clock"></i> 예상 학습 시간: 4시간 30분 | <i class="fas fa-database"></i> 실시간 엔드포인트 실습 | <i class="fas fa-project-diagram"></i> 지식 그래프 프로젝트
</div>

<!-- 학습 전 체크리스트 -->
<div class="pre-learning-checklist">
    <h3>📝 학습 전 확인사항</h3>
    <div class="checklist-grid">
        <div class="checklist-item">
            <input type="checkbox" id="sparql-pre1">
            <label for="sparql-pre1">RDF 트리플 구조 이해 (Chapter 4)</label>
        </div>
        <div class="checklist-item">
            <input type="checkbox" id="sparql-pre2">
            <label for="sparql-pre2">SQL 기본 문법 (도움이 됨)</label>
        </div>
        <div class="checklist-item">
            <input type="checkbox" id="sparql-pre3">
            <label for="sparql-pre3">그래프 데이터 구조 개념</label>
        </div>
        <div class="checklist-item">
            <input type="checkbox" id="sparql-pre4">
            <label for="sparql-pre4">정규 표현식 기초 (선택사항)</label>
        </div>
    </div>
</div>

<!-- 학습 목표 -->
<div class="learning-objectives card master-level">
    <h3><i class="fas fa-bullseye"></i> 학습 목표</h3>
    <div class="objectives-hierarchy">
        <div class="objective-level basic">
            <h4>🌱 기초 마스터 (1시간)</h4>
            <ul>
                <li>SPARQL 탄생 배경과 설계 철학</li>
                <li>4가지 질의 형식 (SELECT, CONSTRUCT, ASK, DESCRIBE)</li>
                <li>기본 트리플 패턴 매칭과 BGP(Basic Graph Pattern)</li>
                <li>필터링과 정렬, 제한 기법</li>
            </ul>
        </div>
        <div class="objective-level intermediate">
            <h4>🌿 중급 테크닉 (1.5시간)</h4>
            <ul>
                <li>OPTIONAL, UNION, MINUS 등 고급 그래프 패턴</li>
                <li>FILTER 함수와 정규식, 문자열 처리</li>
                <li>집계 함수와 GROUP BY, HAVING</li>
                <li>Federated Query로 여러 엔드포인트 통합 조회</li>
            </ul>
        </div>
        <div class="objective-level advanced">
            <h4>🌳 고급 실무 (1시간)</h4>
            <ul>
                <li>Property Path로 복잡한 그래프 탐색</li>
                <li>SPARQL Update로 데이터 조작 (INSERT, DELETE)</li>
                <li>성능 최적화와 인덱싱 전략</li>
                <li>실시간 지식 그래프 분석 시스템 구축</li>
            </ul>
        </div>
        <div class="objective-level expert">
            <h4>🏆 전문가 프로젝트 (1시간)</h4>
            <ul>
                <li>Wikidata, DBpedia 등 대규모 지식 그래프 활용</li>
                <li>GraphQL과 SPARQL 통합 API 설계</li>
                <li>추론 기반 SPARQL로 암묵적 지식 발견</li>
                <li>AI/ML 파이프라인과 통합</li>
            </ul>
        </div>
    </div>
</div>

<!-- 학습 로드맵 -->
<div class="sparql-learning-journey">
    <h3><i class="fas fa-map-marked-alt"></i> SPARQL 마스터 여정</h3>
    <div class="journey-visualization">
        <div class="journey-stage">
            <div class="stage-icon">🎣</div>
            <div class="stage-name">Beginner</div>
            <div class="stage-desc">기본 질의</div>
        </div>
        <div class="journey-path">→</div>
        <div class="journey-stage">
            <div class="stage-icon">🎯</div>
            <div class="stage-name">Practitioner</div>
            <div class="stage-desc">복잡한 패턴</div>
        </div>
        <div class="journey-path">→</div>
        <div class="journey-stage">
            <div class="stage-icon">🥳</div>
            <div class="stage-name">Expert</div>
            <div class="stage-desc">성능 최적화</div>
        </div>
        <div class="journey-path">→</div>
        <div class="journey-stage">
            <div class="stage-icon">🏆</div>
            <div class="stage-name">Master</div>
            <div class="stage-desc">실전 프로젝트</div>
        </div>
    </div>
</div>

<!-- 섹션 7.1: SPARQL 탄생 스토리 -->
<section class="content-section">
    <h2>7.1 SPARQL의 탄생과 철학</h2>
    
    <div class="origin-story">
        <h3>🌟 SQL에서 SPARQL로의 여정</h3>
        <div class="story-narrative">
            <p>2004년, W3C의 한 회의실. 시맨틱 웹 연구자들이 모여 고민하고 있었습니다.</p>
            <blockquote class="developer-quote">
                "우리는 RDF 그래프를 위한 질의 언어가 필요합니다. SQL은 테이블을 위한 것이고, 
                우리에게는 그래프를 위한 무언가가 필요해요."
                <cite>- Andy Seaborne, Apache Jena 개발자</cite>
            </blockquote>
            
            <p>SPARQL은 단순히 SQL을 그래프에 적용한 것이 아닙니다. 그것은 완전히 새로운 사고방식의 전환이었습니다.</p>
        </div>
        
        <div class="philosophy-grid">
            <div class="philosophy-card">
                <div class="card-icon">🔍</div>
                <h4>패턴 매칭의 철학</h4>
                <p>SPARQL은 "이런 패턴을 찾아라"는 선언적 접근을 택했습니다. 
                마치 퍼즐 조각을 맞추듯이 그래프에서 원하는 모양을 찾아내는 것입니다.</p>
            </div>
            <div class="philosophy-card">
                <div class="card-icon">🌐</div>
                <h4>개방성의 원칙</h4>
                <p>닫힌 스키마가 없습니다. SPARQL은 열린 세계 가정(Open World Assumption)을 따르며, 
                모르는 것은 거짓이 아니라 단지 모를 뿐입니다.</p>
            </div>
            <div class="philosophy-card">
                <div class="card-icon">🔗</div>
                <h4>연결의 미학</h4>
                <p>SPARQL은 데이터 간의 연결을 일급 시민으로 대합니다. 
                관계는 단순한 외래키가 아니라 그 자체로 의미를 지닌 존재입니다.</p>
            </div>
        </div>
    </div>

    <div class="technical-evolution">
        <h3>📈 SPARQL의 진화</h3>
        <div class="timeline-container">
            <div class="timeline-event">
                <div class="event-year">2004</div>
                <div class="event-content">
                    <h5>첫 번째 초안</h5>
                    <p>RDF Data Access Working Group 결성. SeRQL, RDQL 등 기존 언어들의 장점을 통합</p>
                </div>
            </div>
            <div class="timeline-event">
                <div class="event-year">2008</div>
                <div class="event-content">
                    <h5>SPARQL 1.0 표준화</h5>
                    <p>W3C 권고안 발표. SELECT, CONSTRUCT, ASK, DESCRIBE 네 가지 질의 형식 확립</p>
                </div>
            </div>
            <div class="timeline-event">
                <div class="event-year">2013</div>
                <div class="event-content">
                    <h5>SPARQL 1.1 혁신</h5>
                    <p>UPDATE 추가, 집계 함수, 서브쿼리, Property Path 등 대폭 강화</p>
                </div>
            </div>
            <div class="timeline-event">
                <div class="event-year">2024</div>
                <div class="event-content">
                    <h5>SPARQL과 AI의 만남</h5>
                    <p>LLM과 지식 그래프 통합, GraphQL과의 융합, 실시간 스트리밍 지원</p>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- 섹션 7.2: SQL vs SPARQL 심층 비교 -->
<section class="content-section">
    <h2>7.2 SQL에서 SPARQL로의 패러다임 전환</h2>
    
    <!-- 스토리텔링 도입 -->
    <div class="sparql-origin-story">
        <h3>🌐 2008년, 시맨틱 웹의 중대한 순간</h3>
        <p>수십억 개의 RDF 트리플이 웹에 흩어져 있었지만, 이를 효과적으로 검색할 방법이 없었습니다. 
        각 시스템마다 다른 질의 언어를 사용했고, 개발자들은 매번 새로운 문법을 배워야 했죠.</p>
        
        <div class="historical-context">
            <div class="before-sparql">
                <h4>SPARQL 이전</h4>
                <ul>
                    <li>RDQL, SeRQL, N3QL 등 파편화된 언어들</li>
                    <li>시스템 간 호환성 없음</li>
                    <li>제한적인 표현력</li>
                    <li>표준화 부재로 인한 혼란</li>
                </ul>
            </div>
            <div class="after-sparql">
                <h4>SPARQL 이후</h4>
                <ul>
                    <li>W3C 표준으로 통일된 문법</li>
                    <li>모든 RDF 스토어에서 동작</li>
                    <li>강력한 그래프 패턴 매칭</li>
                    <li>연합 질의(Federated Query) 지원</li>
                </ul>
            </div>
        </div>
    </div>
    
    <!-- SPARQL 철학 -->
    <div class="sparql-philosophy">
        <h3>🎯 SPARQL의 설계 철학</h3>
        <div class="philosophy-pillars">
            <div class="pillar">
                <h4>1. 선언적(Declarative)</h4>
                <p>"무엇을" 원하는지만 명시하면, "어떻게" 찾을지는 엔진이 최적화</p>
                <div class="example-snippet">
                    <code>?person foaf:knows ?friend</code>
                    <p class="explanation">→ 친구 관계를 찾아라 (방법은 엔진에 위임)</p>
                </div>
            </div>
            <div class="pillar">
                <h4>2. 패턴 기반(Pattern-based)</h4>
                <p>그래프의 "모양"을 그려서 매칭되는 부분을 찾기</p>
                <div class="pattern-visual">
                    <div class="pattern-node">?A</div>
                    <div class="pattern-edge">knows</div>
                    <div class="pattern-node">?B</div>
                    <div class="pattern-edge">knows</div>
                    <div class="pattern-node">?C</div>
                </div>
            </div>
            <div class="pillar">
                <h4>3. 확장 가능(Extensible)</h4>
                <p>기본 기능에 추론, 지리정보, 전문검색 등 확장 가능</p>
                <ul>
                    <li>GeoSPARQL: 지리공간 질의</li>
                    <li>SPARQL-ML: 머신러닝 통합</li>
                    <li>EntailmentRegime: 추론 지원</li>
                </ul>
            </div>
        </div>
    </div>
    
    <!-- 핵심 개념 재정의 -->
    <div class="concept-box enhanced">
        <h4><i class="fas fa-lightbulb"></i> SPARQL의 진정한 힘</h4>
        <div class="power-grid">
            <div class="power-item">
                <h5>🔍 발견적 질의</h5>
                <p>스키마를 몰라도 데이터 탐색 가능</p>
            </div>
            <div class="power-item">
                <h5>🌐 분산 질의</h5>
                <p>여러 데이터 소스를 하나로</p>
            </div>
            <div class="power-item">
                <h5>🧠 추론 통합</h5>
                <p>명시되지 않은 사실도 검색</p>
            </div>
            <div class="power-item">
                <h5>🔄 다형성</h5>
                <p>SELECT, CONSTRUCT, ASK, DESCRIBE</p>
            </div>
        </div>
    </div>
    
    <!-- SPARQL vs SQL 심화 비교 -->
    <div class="deep-comparison">
        <h3>🔄 SPARQL vs SQL: 패러다임의 전환</h3>
        
        <!-- 시각적 비교 -->
        <div class="paradigm-comparison">
            <div class="paradigm-sql">
                <h4>SQL 세계관</h4>
                <div class="world-view">
                    <div class="concept">정형화된 테이블</div>
                    <div class="concept">미리 정의된 관계</div>
                    <div class="concept">닫힌 세계 가정</div>
                </div>
            </div>
            <div class="vs-symbol">VS</div>
            <div class="paradigm-sparql">
                <h4>SPARQL 세계관</h4>
                <div class="world-view">
                    <div class="concept">자유로운 그래프</div>
                    <div class="concept">동적 관계 발견</div>
                    <div class="concept">열린 세계 가정</div>
                </div>
            </div>
        </div>
        
        <!-- 실제 예시로 보는 차이 -->
        <div class="comparison-by-example">
            <h4>💡 같은 질문, 다른 접근</h4>
            <div class="query-comparison">
                <div class="query-scenario">
                    <p><strong>질문:</strong> "John의 친구들의 친구들 중에서 프로그래머인 사람을 찾아라"</p>
                </div>
                
                <div class="sql-approach">
                    <h5>SQL 접근법</h5>
                    <pre class="code-block">
SELECT DISTINCT f2.name
FROM persons p
JOIN friendships f1 ON p.id = f1.person_id
JOIN persons friend1 ON f1.friend_id = friend1.id
JOIN friendships f2 ON friend1.id = f2.person_id
JOIN persons friend2 ON f2.friend_id = friend2.id
JOIN person_jobs pj ON friend2.id = pj.person_id
JOIN jobs j ON pj.job_id = j.id
WHERE p.name = 'John' 
  AND j.title = 'Programmer'
  AND friend2.id != p.id;
                    </pre>
                    <div class="approach-analysis">
                        <p>❌ 복잡한 다중 JOIN</p>
                        <p>❌ 테이블 구조에 의존적</p>
                        <p>❌ 관계의 깊이가 바뀌면 쿼리 재작성</p>
                    </div>
                </div>
                
                <div class="sparql-approach">
                    <h5>SPARQL 접근법</h5>
                    <pre class="code-block">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX ex: &lt;http://example.org/&gt;

SELECT DISTINCT ?programmer
WHERE {
  ex:John foaf:knows/foaf:knows ?programmer .
  ?programmer ex:hasJob "Programmer" .
  FILTER (?programmer != ex:John)
}
                    </pre>
                    <div class="approach-analysis">
                        <p>✅ 직관적인 경로 표현 (/)</p>
                        <p>✅ 자연스러운 그래프 탐색</p>
                        <p>✅ 확장 가능한 패턴</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 상세 비교 테이블 -->
        <div class="detailed-comparison-table">
            <table class="comparison-table-enhanced">
                <thead>
                    <tr>
                        <th>차원</th>
                        <th>SQL</th>
                        <th>SPARQL</th>
                        <th>실무 영향</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>데이터 모델</td>
                        <td>2D 테이블 (행과 열)</td>
                        <td>3D 그래프 (주어-서술어-목적어)</td>
                        <td>SPARQL은 복잡한 관계를 자연스럽게 표현</td>
                    </tr>
                    <tr>
                        <td>스키마 유연성</td>
                        <td>DDL로 사전 정의 필수</td>
                        <td>스키마 없이도 데이터 추가 가능</td>
                        <td>빠른 프로토타이핑과 진화하는 데이터 모델에 유리</td>
                    </tr>
                    <tr>
                        <td>NULL 처리</td>
                        <td>3-valued logic (TRUE/FALSE/NULL)</td>
                        <td>존재하지 않음 = 매칭 실패</td>
                        <td>OPTIONAL로 명시적 처리 필요</td>
                    </tr>
                    <tr>
                        <td>조인 방식</td>
                        <td>명시적 JOIN 키워드</td>
                        <td>공통 변수로 암묵적 조인</td>
                        <td>복잡한 조인도 간결하게 표현</td>
                    </tr>
                    <tr>
                        <td>재귀 질의</td>
                        <td>WITH RECURSIVE (복잡함)</td>
                        <td>Property Path (+, *, ?)</td>
                        <td>계층 구조 탐색이 매우 간단</td>
                    </tr>
                    <tr>
                        <td>다형성</td>
                        <td>SELECT만 가능</td>
                        <td>SELECT/CONSTRUCT/ASK/DESCRIBE</td>
                        <td>용도에 맞는 결과 형태 선택 가능</td>
                    </tr>
                    <tr>
                        <td>분산 질의</td>
                        <td>Database Link (벤더 종속)</td>
                        <td>SERVICE 키워드 (표준)</td>
                        <td>여러 데이터 소스 통합 질의 용이</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</section>

<!-- 섹션 7.3: SPARQL 기본 구조와 패턴 -->
<section class="content-section">
    <h2>7.3 SPARQL 기본 구조 마스터</h2>
    
    <div class="structure-overview">
        <h3>🏗️ SPARQL 쿼리의 건축학</h3>
        <p>SPARQL 쿼리는 레고 블록처럼 조립됩니다. 각 부분이 정확한 역할을 가지고 있죠.</p>
        
        <div class="query-anatomy">
            <div class="anatomy-layer">
                <div class="layer-name">PREFIX 선언부</div>
                <div class="layer-desc">네임스페이스 축약 정의</div>
                <pre><code>PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;</code></pre>
            </div>
            <div class="anatomy-layer">
                <div class="layer-name">쿼리 형식</div>
                <div class="layer-desc">SELECT / CONSTRUCT / ASK / DESCRIBE</div>
                <pre><code>SELECT ?name ?age</code></pre>
            </div>
            <div class="anatomy-layer">
                <div class="layer-name">패턴 매칭부</div>
                <div class="layer-desc">WHERE 절에서 트리플 패턴 정의</div>
                <pre><code>WHERE { ?person foaf:name ?name }</code></pre>
            </div>
            <div class="anatomy-layer">
                <div class="layer-name">수식어</div>
                <div class="layer-desc">ORDER BY, LIMIT, OFFSET 등</div>
                <pre><code>ORDER BY ?name LIMIT 10</code></pre>
            </div>
        </div>
    </div>

    <div class="pattern-matching-deep">
        <h3>🎯 패턴 매칭의 예술</h3>
        
        <div class="pattern-evolution">
            <h4>초급: 단순 트리플 패턴</h4>
            <pre><code class="language-sparql"># 한 명의 사람 찾기
?person a foaf:Person .
?person foaf:name "John" .</code></pre>
            
            <h4>중급: 복합 패턴</h4>
            <pre><code class="language-sparql"># 친구의 친구 찾기
?person foaf:knows ?friend .
?friend foaf:knows ?friendOfFriend .
?friendOfFriend foaf:name ?name .</code></pre>
            
            <h4>고급: 패턴 체인</h4>
            <pre><code class="language-sparql"># 프로젝트 참여자의 전문 분야 찾기
?project dbo:participant ?person .
?person foaf:interest ?interest .
?interest skos:broader ?domain .
FILTER(regex(?domain, "AI|Machine Learning", "i"))</code></pre>
        </div>
    </div>

    <div class="query-forms-comparison">
        <h3>🌈 4가지 쿼리 형식 비교</h3>
        <div class="forms-grid">
            <div class="query-form-card">
                <h4>SELECT - 데이터 선택</h4>
                <div class="form-purpose">테이블 형태로 결과 반환</div>
                <pre><code>SELECT ?name ?email
WHERE {
    ?person foaf:name ?name ;
            foaf:mbox ?email .
}</code></pre>
                <div class="use-case">💡 사용 예: 사용자 목록 조회</div>
            </div>
            
            <div class="query-form-card">
                <h4>CONSTRUCT - 그래프 생성</h4>
                <div class="form-purpose">새로운 RDF 그래프 구성</div>
                <pre><code>CONSTRUCT {
    ?person ex:hasColleague ?colleague
}
WHERE {
    ?person ex:worksAt ?company .
    ?colleague ex:worksAt ?company .
    FILTER(?person != ?colleague)
}</code></pre>
                <div class="use-case">💡 사용 예: 추론된 관계 생성</div>
            </div>
            
            <div class="query-form-card">
                <h4>ASK - 존재 확인</h4>
                <div class="form-purpose">true/false 반환</div>
                <pre><code>ASK {
    ?person foaf:name "Alice" ;
            foaf:age ?age .
    FILTER(?age >= 18)
}</code></pre>
                <div class="use-case">💡 사용 예: 권한 확인</div>
            </div>
            
            <div class="query-form-card">
                <h4>DESCRIBE - 자원 설명</h4>
                <div class="form-purpose">자원에 대한 모든 정보</div>
                <pre><code>DESCRIBE ?person
WHERE {
    ?person foaf:name "Bob" .
}</code></pre>
                <div class="use-case">💡 사용 예: 엔티티 탐색</div>
            </div>
        </div>
    </div>

    <div class="advanced-patterns">
        <h3>🔥 고급 패턴 매칭 기법</h3>
        
        <div class="pattern-techniques">
            <div class="technique-card">
                <h4>1. 선택적 패턴 (OPTIONAL)</h4>
                <pre><code class="language-sparql">SELECT ?name ?email ?phone
WHERE {
    ?person foaf:name ?name .
    OPTIONAL { ?person foaf:mbox ?email }
    OPTIONAL { ?person foaf:phone ?phone }
}</code></pre>
                <p>👉 이메일이나 전화번호가 없어도 결과에 포함</p>
            </div>
            
            <div class="technique-card">
                <h4>2. 대체 패턴 (UNION)</h4>
                <pre><code class="language-sparql">SELECT ?name ?contact
WHERE {
    ?person foaf:name ?name .
    { ?person foaf:mbox ?contact }
    UNION
    { ?person foaf:phone ?contact }
}</code></pre>
                <p>👉 이메일 또는 전화번호 중 하나를 반환</p>
            </div>
            
            <div class="technique-card">
                <h4>3. 제외 패턴 (MINUS)</h4>
                <pre><code class="language-sparql">SELECT ?person ?name
WHERE {
    ?person a foaf:Person ;
            foaf:name ?name .
    MINUS {
        ?person ex:status "inactive" .
    }
}</code></pre>
                <p>👉 비활성 사용자 제외</p>
            </div>
        </div>
    </div>
        </div>
    </div>
    
    <h3>SPARQL 질의 유형</h3>
    <div class="query-types">
        <div class="query-type-card">
            <h4>SELECT</h4>
            <p>특정 변수의 값을 반환</p>
            <div class="usage">테이블 형태의 결과</div>
        </div>
        
        <div class="query-type-card">
            <h4>CONSTRUCT</h4>
            <p>새로운 RDF 그래프 생성</p>
            <div class="usage">데이터 변환에 사용</div>
        </div>
        
        <div class="query-type-card">
            <h4>ASK</h4>
            <p>조건 만족 여부 확인</p>
            <div class="usage">true/false 반환</div>
        </div>
        
        <div class="query-type-card">
            <h4>DESCRIBE</h4>
            <p>자원에 대한 정보 반환</p>
            <div class="usage">RDF 그래프 반환</div>
        </div>
    </div>
</section>

<!-- 섹션 7.4: FILTER와 함수 -->
<section class="content-section">
    <h2>7.4 FILTER와 함수 마스터</h2>
    
    <div class="filter-intro">
        <h3>🎯 FILTER의 힘</h3>
        <p>FILTER는 SPARQL의 WHERE 절과 같습니다. 패턴 매칭 결과를 세밀하게 조정합니다.</p>
    </div>

    <div class="filter-categories">
        <h3>📦 FILTER 함수 카테고리</h3>
        
        <div class="function-category">
            <h4>1. 비교 연산자</h4>
            <div class="function-examples">
                <pre><code class="language-sparql"># 숫자 비교
FILTER(?age >= 18 && ?age < 65)

# 문자열 비교
FILTER(?name > "M")  # M으로 시작하는 이름 이후

# 날짜 비교
FILTER(?date > "2024-01-01"^^xsd:date)</code></pre>
            </div>
        </div>
        
        <div class="function-category">
            <h4>2. 문자열 함수</h4>
            <div class="function-examples">
                <pre><code class="language-sparql"># 정규식 매칭
FILTER(regex(?email, "@(gmail|yahoo)\\.com$", "i"))

# 문자열 포함
FILTER(contains(?description, "AI"))

# 시작/끝 검사
FILTER(strstarts(?url, "https://"))
FILTER(strends(?file, ".pdf"))

# 대소문자 변환
FILTER(lcase(?name) = "john")</code></pre>
            </div>
        </div>
        
        <div class="function-category">
            <h4>3. 숫자 함수</h4>
            <div class="function-examples">
                <pre><code class="language-sparql"># 수학 연산
FILTER(abs(?temperature) < 100)
FILTER(round(?price) = 10)
FILTER(floor(?rating) >= 4)

# 조합 연산
FILTER(?quantity * ?price > 1000)</code></pre>
            </div>
        </div>
        
        <div class="function-category">
            <h4>4. 날짜/시간 함수</h4>
            <div class="function-examples">
                <pre><code class="language-sparql"># 현재 시간 비교
FILTER(?eventDate > now())

# 날짜 추출
FILTER(year(?birthDate) = 1990)
FILTER(month(?date) IN (6, 7, 8))  # 여름

# 시간대 조건
FILTER(hours(?time) >= 9 && hours(?time) < 18)</code></pre>
            </div>
        </div>
        
        <div class="function-category">
            <h4>5. 타입 검사 함수</h4>
            <div class="function-examples">
                <pre><code class="language-sparql"># 리터럴 타입 검사
FILTER(isLiteral(?value))
FILTER(isNumeric(?price))
FILTER(isIRI(?resource))

# 언어 태그 검사
FILTER(lang(?label) = "ko")
FILTER(langMatches(lang(?text), "en-*"))</code></pre>
            </div>
        </div>
    </div>

    <div class="advanced-filter-patterns">
        <h3>🔥 고급 FILTER 패턴</h3>
        
        <div class="pattern-example">
            <h4>예제 1: 복합 조건</h4>
            <pre><code class="language-sparql">SELECT ?product ?price ?rating
WHERE {
    ?product a ex:Product ;
             ex:price ?price ;
             ex:rating ?rating ;
             ex:category ?category .
    
    # 복합 필터 조건
    FILTER(
        ?price < 100 &&
        ?rating >= 4.0 &&
        (?category = "Electronics" || ?category = "Books") &&
        !bound(?discontinued)  # 단종되지 않은 제품
    )
}</code></pre>
        </div>
        
        <div class="pattern-example">
            <h4>예제 2: 동적 조건</h4>
            <pre><code class="language-sparql">SELECT ?event ?date ?venue
WHERE {
    ?event a ex:Event ;
           ex:date ?date ;
           ex:venue ?venue .
    
    # 다음 달 이벤트 찾기
    FILTER(
        year(?date) = year(now()) &&
        month(?date) = month(now()) + 1
    )
    
    # 주말 이벤트만
    FILTER(
        dayOfWeek(?date) IN (6, 7)
    )
}</code></pre>
        </div>
        
        <div class="pattern-example">
            <h4>예제 3: 조건부 필터링</h4>
            <pre><code class="language-sparql">SELECT ?person ?name ?discount
WHERE {
    ?person foaf:name ?name ;
            ex:age ?age ;
            ex:memberSince ?joinDate .
    
    # 조건에 따른 할인율 계산
    BIND(
        IF(?age >= 65, 0.2,
            IF(year(now()) - year(?joinDate) > 5, 0.15,
                IF(?age < 25, 0.1, 0.0)
            )
        ) AS ?discount
    )
    
    FILTER(?discount > 0)  # 할인 대상자만
}</code></pre>
        </div>
    </div>

    <div class="filter-best-practices">
        <h3>💡 FILTER 베스트 프랙티스</h3>
        <div class="practice-cards">
            <div class="practice-card">
                <h4>✅ 효율적인 필터링</h4>
                <ul>
                    <li>패턴 매칭 후 FILTER 적용</li>
                    <li>가장 제한적인 조건부터 적용</li>
                    <li>인덱스된 속성 활용</li>
                </ul>
            </div>
            <div class="practice-card">
                <h4>⚠️ 피해야 할 패턴</h4>
                <ul>
                    <li>과도한 regex 사용</li>
                    <li>FILTER 내 복잡한 계산</li>
                    <li>여러 FILTER를 하나로 통합</li>
                </ul>
            </div>
        </div>
    </div>
</section>

<!-- 섹션 7.5: 집계 함수와 GROUP BY -->
<section class="content-section">
    <h2>7.5 집계 함수와 그룹핑</h2>
    
    <div class="aggregation-intro">
        <h3>📊 데이터 집계의 힘</h3>
        <p>SPARQL 1.1에서 추가된 집계 기능은 대규모 데이터 분석을 가능하게 합니다.</p>
    </div>

    <div class="aggregation-functions">
        <h3>🧮 집계 함수 전체 가이드</h3>
        
        <div class="function-grid">
            <div class="agg-function">
                <h4>COUNT</h4>
                <div class="function-syntax">COUNT(?var) / COUNT(*) / COUNT(DISTINCT ?var)</div>
                <pre><code># 도시별 사용자 수
SELECT ?city (COUNT(?person) AS ?userCount)
WHERE {
    ?person ex:livesIn ?city .
}
GROUP BY ?city
ORDER BY DESC(?userCount)</code></pre>
            </div>
            
            <div class="agg-function">
                <h4>SUM / AVG</h4>
                <div class="function-syntax">SUM(?numeric) / AVG(?numeric)</div>
                <pre><code># 부서별 평균 급여
SELECT ?dept (AVG(?salary) AS ?avgSalary)
WHERE {
    ?employee ex:department ?dept ;
              ex:salary ?salary .
}
GROUP BY ?dept
HAVING(AVG(?salary) > 50000)</code></pre>
            </div>
            
            <div class="agg-function">
                <h4>MIN / MAX</h4>
                <div class="function-syntax">MIN(?value) / MAX(?value)</div>
                <pre><code># 카테고리별 가격 범위
SELECT ?category 
       (MIN(?price) AS ?minPrice)
       (MAX(?price) AS ?maxPrice)
WHERE {
    ?product ex:category ?category ;
             ex:price ?price .
}
GROUP BY ?category</code></pre>
            </div>
            
            <div class="agg-function">
                <h4>GROUP_CONCAT</h4>
                <div class="function-syntax">GROUP_CONCAT(?var; separator=",")</div>
                <pre><code># 저자별 책 목록
SELECT ?author 
       (GROUP_CONCAT(?title; separator=" | ") AS ?books)
WHERE {
    ?book ex:author ?author ;
          ex:title ?title .
}
GROUP BY ?author</code></pre>
            </div>
            
            <div class="agg-function">
                <h4>SAMPLE</h4>
                <div class="function-syntax">SAMPLE(?var)</div>
                <pre><code># 그룹별 예시 데이터
SELECT ?category 
       (COUNT(*) AS ?count)
       (SAMPLE(?product) AS ?example)
WHERE {
    ?product ex:category ?category .
}
GROUP BY ?category</code></pre>
            </div>
        </div>
    </div>

    <div class="grouping-patterns">
        <h3>🎯 GROUP BY 패턴</h3>
        
        <div class="pattern-showcase">
            <h4>패턴 1: 다중 그룹핑</h4>
            <pre><code class="language-sparql">SELECT ?year ?month ?category
       (SUM(?amount) AS ?totalSales)
       (COUNT(DISTINCT ?customer) AS ?uniqueCustomers)
WHERE {
    ?sale ex:date ?date ;
          ex:amount ?amount ;
          ex:category ?category ;
          ex:customer ?customer .
    
    BIND(year(?date) AS ?year)
    BIND(month(?date) AS ?month)
}
GROUP BY ?year ?month ?category
ORDER BY ?year ?month ?category</code></pre>
        </div>
        
        <div class="pattern-showcase">
            <h4>패턴 2: HAVING으로 필터링</h4>
            <pre><code class="language-sparql">SELECT ?author 
       (COUNT(?book) AS ?bookCount)
       (AVG(?rating) AS ?avgRating)
WHERE {
    ?book ex:author ?author ;
          ex:rating ?rating .
}
GROUP BY ?author
HAVING(COUNT(?book) >= 5 && AVG(?rating) > 4.0)
ORDER BY DESC(?avgRating)</code></pre>
        </div>
        
        <div class="pattern-showcase">
            <h4>패턴 3: 중첩 집계</h4>
            <pre><code class="language-sparql">SELECT ?company
       (COUNT(DISTINCT ?dept) AS ?deptCount)
       (COUNT(?employee) AS ?totalEmployees)
       (AVG(?avgDeptSize) AS ?avgDepartmentSize)
WHERE {
    {
        SELECT ?company ?dept 
               (COUNT(?employee) AS ?avgDeptSize)
        WHERE {
            ?employee ex:worksAt ?company ;
                     ex:department ?dept .
        }
        GROUP BY ?company ?dept
    }
}
GROUP BY ?company
ORDER BY DESC(?totalEmployees)</code></pre>
        </div>
    </div>

    <div class="real-world-analytics">
        <h3>🌍 실전 분석 예제</h3>
        
        <div class="analytics-example">
            <h4>예제: 소셜 네트워크 분석</h4>
            <pre><code class="language-sparql">PREFIX foaf: <http://xmlns.com/foaf/0.1/>

# 인플루언서 분석: 팔로워가 많고 활발한 사용자
SELECT ?user ?name
       (COUNT(DISTINCT ?follower) AS ?followerCount)
       (COUNT(DISTINCT ?post) AS ?postCount)
       (AVG(?likes) AS ?avgLikes)
       (?followerCount * ?avgLikes AS ?influenceScore)
WHERE {
    ?user foaf:name ?name .
    
    # 팔로워
    ?follower ex:follows ?user .
    
    # 게시물과 좋아요
    ?post ex:author ?user ;
          ex:likes ?likes ;
          ex:date ?postDate .
    
    # 최근 30일 활동
    FILTER(?postDate > now() - "P30D"^^xsd:duration)
}
GROUP BY ?user ?name
HAVING(COUNT(DISTINCT ?follower) > 1000)
ORDER BY DESC(?influenceScore)
LIMIT 100</code></pre>
        </div>
    </div>
</section>

<!-- 섹션 7.6: Property Path와 그래프 탐색 -->
<section class="content-section">
    <h2>7.6 Property Path - 그래프 탐색의 마법</h2>
    
    <div class="property-path-intro">
        <h3>🌐 경로 표현의 혁명</h3>
        <p>Property Path는 복잡한 그래프 구조를 간결하게 표현하는 SPARQL 1.1의 강력한 기능입니다.</p>
        
        <div class="path-notation-guide">
            <h4>🔀 경로 표기법</h4>
            <table class="path-operators">
                <thead>
                    <tr>
                        <th>연산자</th>
                        <th>의미</th>
                        <th>예제</th>
                        <th>설명</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>/</code></td>
                        <td>순차적 연결</td>
                        <td><code>foaf:knows/foaf:name</code></td>
                        <td>친구의 이름</td>
                    </tr>
                    <tr>
                        <td><code>|</code></td>
                        <td>대체 경로</td>
                        <td><code>ex:parent|ex:guardian</code></td>
                        <td>부모 또는 보호자</td>
                    </tr>
                    <tr>
                        <td><code>^</code></td>
                        <td>역방향</td>
                        <td><code>^ex:hasChild</code></td>
                        <td>누군가의 부모</td>
                    </tr>
                    <tr>
                        <td><code>*</code></td>
                        <td>0회 이상 반복</td>
                        <td><code>foaf:knows*</code></td>
                        <td>모든 연결된 사람</td>
                    </tr>
                    <tr>
                        <td><code>+</code></td>
                        <td>1회 이상 반복</td>
                        <td><code>rdfs:subClassOf+</code></td>
                        <td>모든 상위 클래스</td>
                    </tr>
                    <tr>
                        <td><code>?</code></td>
                        <td>0회 또는 1회</td>
                        <td><code>ex:spouse?</code></td>
                        <td>배우자(선택적)</td>
                    </tr>
                    <tr>
                        <td><code>{n,m}</code></td>
                        <td>n~m회 반복</td>
                        <td><code>foaf:knows{2,4}</code></td>
                        <td>2~4촌 관계</td>
                    </tr>
                    <tr>
                        <td><code>!</code></td>
                        <td>부정</td>
                        <td><code>!rdf:type</code></td>
                        <td>type 이외의 모든 속성</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
    <div class="variable-constant">
        <div class="var-const-example">
            <h4>변수 사용</h4>
            <pre class="sparql-code">
# 변수는 ?나 $로 시작
SELECT ?person ?age
WHERE {
    ?person :hasAge ?age .
}
            </pre>
        </div>
        
        <div class="var-const-example">
            <h4>상수와 혼합</h4>
            <pre class="sparql-code">
# 특정 사람의 나이 조회
SELECT ?age
WHERE {
    :홍길동 :hasAge ?age .
}
            </pre>
        </div>
    </div>
    
    <h3>복잡한 패턴 매칭</h3>
    <div class="complex-patterns">
        <h4>다중 패턴 예제</h4>
        <pre class="sparql-code">
PREFIX : &lt;http://example.org/&gt;
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name ?email ?workplace
WHERE {
    ?person foaf:name ?name .
    ?person foaf:mbox ?email .
    ?person :worksAt ?company .
    ?company :name ?workplace .
}
        </pre>
        
        <div class="pattern-diagram">
            <div class="graph-pattern">
                <div class="node person">?person</div>
                <div class="edge">→ foaf:name →</div>
                <div class="node">?name</div>
                <br>
                <div class="edge">→ foaf:mbox →</div>
                <div class="node">?email</div>
                <br>
                <div class="edge">→ :worksAt →</div>
                <div class="node company">?company</div>
                <div class="edge">→ :name →</div>
                <div class="node">?workplace</div>
            </div>
        </div>
    </div>
    
    <!-- RDF 에디터 링크 추가 -->
    <div class="practice-box" style="margin-top: 2rem; padding: 1.5rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px; color: white;">
        <h3 style="margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            <i class="fas fa-code"></i> SPARQL 쿼리 실습하기
        </h3>
        <p style="margin-bottom: 1rem;">RDF 에디터에서 트리플을 생성한 후, SPARQL 쿼리로 데이터를 검색해보세요!</p>
        <a href="/rdf-editor" target="_blank" style="display: inline-block; padding: 0.75rem 1.5rem; background: white; color: #667eea; text-decoration: none; border-radius: 5px; font-weight: bold; transition: transform 0.2s;">
            RDF 비주얼 에디터 열기 →
        </a>
        <p style="margin-top: 1rem; font-size: 0.9rem; opacity: 0.9;">
            💡 먼저 에디터에서 트리플 데이터를 만든 다음, SPARQL 패턴으로 검색하는 방법을 익혀보세요.
        </p>
    </div>
</section>

<!-- 섹션 7.4 -->
<section class="content-section">
    <h2>7.4 필터와 연산자</h2>
    
    <p>FILTER를 사용하여 결과를 제한하고 정제할 수 있습니다.</p>
    
    <h3>기본 필터링</h3>
    <div class="filter-examples">
        <div class="filter-card">
            <h4>숫자 비교</h4>
            <pre class="sparql-code">
SELECT ?name ?age
WHERE {
    ?person foaf:name ?name .
    ?person :age ?age .
    FILTER (?age >= 18)
}
            </pre>
        </div>
        
        <div class="filter-card">
            <h4>문자열 필터</h4>
            <pre class="sparql-code">
SELECT ?name
WHERE {
    ?person foaf:name ?name .
    FILTER (CONTAINS(?name, "김"))
}
            </pre>
        </div>
        
        <div class="filter-card">
            <h4>정규표현식</h4>
            <pre class="sparql-code">
SELECT ?email
WHERE {
    ?person foaf:mbox ?email .
    FILTER (REGEX(?email, "@gmail\\.com$"))
}
            </pre>
        </div>
        
        <div class="filter-card">
            <h4>언어 필터</h4>
            <pre class="sparql-code">
SELECT ?name
WHERE {
    ?person rdfs:label ?name .
    FILTER (LANG(?name) = "ko")
}
            </pre>
        </div>
    </div>
    
    <h3>내장 함수</h3>
    <div class="built-in-functions">
        <div class="function-category">
            <h4>문자열 함수</h4>
            <ul>
                <li>STR() - 문자열 변환</li>
                <li>STRLEN() - 문자열 길이</li>
                <li>UCASE() / LCASE() - 대소문자 변환</li>
                <li>CONCAT() - 문자열 연결</li>
                <li>SUBSTR() - 부분 문자열</li>
            </ul>
        </div>
        
        <div class="function-category">
            <h4>숫자 함수</h4>
            <ul>
                <li>ABS() - 절대값</li>
                <li>ROUND() - 반올림</li>
                <li>CEIL() / FLOOR() - 올림/내림</li>
                <li>RAND() - 난수</li>
            </ul>
        </div>
        
        <div class="function-category">
            <h4>날짜 함수</h4>
            <ul>
                <li>NOW() - 현재 시간</li>
                <li>YEAR() / MONTH() / DAY()</li>
                <li>HOURS() / MINUTES()</li>
            </ul>
        </div>
    </div>
</section>

<!-- 섹션 7.5 -->
<section class="content-section">
    <h2>7.5 옵셔널 패턴과 유니온</h2>
    
    <h3>OPTIONAL - 선택적 매칭</h3>
    <div class="optional-pattern">
        <pre class="sparql-code">
SELECT ?name ?email ?phone
WHERE {
    ?person foaf:name ?name .
    OPTIONAL { ?person foaf:mbox ?email }
    OPTIONAL { ?person :phone ?phone }
}
        </pre>
        <p class="explanation">이메일이나 전화번호가 없어도 이름은 반환됩니다.</p>
    </div>
    
    <h3>UNION - 대체 패턴</h3>
    <div class="union-pattern">
        <pre class="sparql-code">
SELECT ?name ?contact
WHERE {
    ?person foaf:name ?name .
    {
        ?person foaf:mbox ?contact
    } UNION {
        ?person :phone ?contact
    }
}
        </pre>
        <p class="explanation">이메일 또는 전화번호 중 하나를 연락처로 반환합니다.</p>
    </div>
    
    <h3>NOT EXISTS - 부정 패턴</h3>
    <div class="not-exists-pattern">
        <pre class="sparql-code">
SELECT ?person
WHERE {
    ?person a :Student .
    FILTER NOT EXISTS {
        ?person :hasGraduated true
    }
}
        </pre>
        <p class="explanation">아직 졸업하지 않은 학생들만 조회합니다.</p>
    </div>
</section>

<!-- 섹션 7.6 -->
<section class="content-section">
    <h2>7.6 집계와 그룹화</h2>
    
    <h3>집계 함수</h3>
    <div class="aggregation-functions">
        <div class="agg-example">
            <h4>COUNT - 개수 세기</h4>
            <pre class="sparql-code">
SELECT (COUNT(?student) AS ?studentCount)
WHERE {
    ?student a :Student
}
            </pre>
        </div>
        
        <div class="agg-example">
            <h4>AVG/SUM - 평균/합계</h4>
            <pre class="sparql-code">
SELECT (AVG(?score) AS ?avgScore)
       (SUM(?score) AS ?totalScore)
WHERE {
    ?student :hasScore ?score
}
            </pre>
        </div>
        
        <div class="agg-example">
            <h4>MIN/MAX - 최소/최대</h4>
            <pre class="sparql-code">
SELECT (MIN(?age) AS ?youngest)
       (MAX(?age) AS ?oldest)
WHERE {
    ?person :age ?age
}
            </pre>
        </div>
    </div>
    
    <h3>GROUP BY와 HAVING</h3>
    <div class="grouping-example">
        <pre class="sparql-code">
SELECT ?department (COUNT(?student) AS ?count)
WHERE {
    ?student :belongsTo ?department
}
GROUP BY ?department
HAVING (COUNT(?student) > 10)
ORDER BY DESC(?count)
        </pre>
        <p class="explanation">부서별 학생 수를 집계하고 10명 이상인 부서만 표시합니다.</p>
    </div>
</section>

<!-- 섹션 7.7 -->
<section class="content-section">
    <h2>7.7 정렬과 페이징</h2>
    
    <h3>ORDER BY - 정렬</h3>
    <div class="ordering-examples">
        <pre class="sparql-code">
SELECT ?name ?age
WHERE {
    ?person foaf:name ?name .
    ?person :age ?age
}
ORDER BY DESC(?age) ?name
        </pre>
        <p class="explanation">나이 내림차순, 같은 나이는 이름 오름차순으로 정렬</p>
    </div>
    
    <h3>LIMIT과 OFFSET - 페이징</h3>
    <div class="paging-example">
        <pre class="sparql-code">
SELECT ?title ?author
WHERE {
    ?book :title ?title .
    ?book :author ?author
}
ORDER BY ?title
LIMIT 10
OFFSET 20
        </pre>
        <p class="explanation">21번째부터 30번째까지의 책 정보를 반환합니다.</p>
    </div>
</section>

<!-- 섹션 7.8 -->
<section class="content-section">
    <h2>7.8 실전 SPARQL 질의</h2>
    
    <h3>복잡한 질의 예제</h3>
    <div class="complex-query-example">
        <h4>도서관 시스템 질의</h4>
        <pre class="sparql-code">
PREFIX lib: &lt;http://example.org/library#&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

# 가장 많이 대출된 책 Top 10
SELECT ?title (COUNT(?loan) AS ?loanCount)
WHERE {
    ?book dc:title ?title .
    ?loan lib:borrowedItem ?book .
    ?loan lib:borrowDate ?date .
    
    # 최근 1년 이내 대출만
    FILTER (?date > NOW() - "P1Y"^^xsd:duration)
}
GROUP BY ?title
ORDER BY DESC(?loanCount)
LIMIT 10
        </pre>
    </div>
    
    <h3>페더레이션 질의</h3>
    <div class="federation-example">
        <h4>여러 데이터 소스 결합</h4>
        <pre class="sparql-code">
SELECT ?drug ?disease ?sideEffect
WHERE {
    # 로컬 데이터베이스에서 약품 정보
    ?drug a :Drug ;
          :treats ?disease .
    
    # 외부 DBpedia에서 부작용 정보
    SERVICE &lt;https://dbpedia.org/sparql&gt; {
        ?drug dbo:sideEffect ?sideEffect .
    }
}
        </pre>
    </div>
</section>

<!-- 섹션 7.9 -->
<section class="content-section">
    <h2>7.9 SPARQL 업데이트</h2>
    
    <p>SPARQL 1.1부터는 데이터 수정도 가능합니다.</p>
    
    <h3>INSERT DATA</h3>
    <div class="update-example">
        <pre class="sparql-code">
PREFIX : &lt;http://example.org/&gt;

INSERT DATA {
    :김철수 a :Person ;
           :name "김철수" ;
           :age 25 ;
           :email "kim@example.com" .
}
        </pre>
    </div>
    
    <h3>DELETE/INSERT</h3>
    <div class="update-example">
        <pre class="sparql-code">
DELETE { ?person :age ?oldAge }
INSERT { ?person :age ?newAge }
WHERE {
    ?person :name "김철수" ;
            :age ?oldAge .
    BIND (?oldAge + 1 AS ?newAge)
}
        </pre>
    </div>
    
    <h3>DELETE WHERE</h3>
    <div class="update-example">
        <pre class="sparql-code">
DELETE WHERE {
    ?person :temporaryFlag true
}
        </pre>
    </div>
</section>

<!-- 섹션 7.10 -->
<section class="content-section">
    <h2>7.10 SPARQL 엔드포인트 활용</h2>
    
    <h3>공개 SPARQL 엔드포인트</h3>
    <div class="endpoint-list">
        <div class="endpoint-card">
            <h4>DBpedia</h4>
            <p class="endpoint-url">https://dbpedia.org/sparql</p>
            <p>위키피디아 데이터의 RDF 버전</p>
        </div>
        
        <div class="endpoint-card">
            <h4>Wikidata</h4>
            <p class="endpoint-url">https://query.wikidata.org/</p>
            <p>구조화된 지식 베이스</p>
        </div>
        
        <div class="endpoint-card">
            <h4>국립중앙도서관 LOD</h4>
            <p class="endpoint-url">http://lod.nl.go.kr/sparql</p>
            <p>한국 서지 데이터</p>
        </div>
    </div>
    
    <h3>실습: Wikidata 질의</h3>
    <div class="wikidata-example">
        <h4>한국의 도시 인구 조회</h4>
        <pre class="sparql-code">
SELECT ?city ?cityLabel ?population
WHERE {
    ?city wdt:P31 wd:Q515 ;          # 도시
          wdt:P17 wd:Q884 ;          # 한국
          wdt:P1082 ?population .    # 인구
    
    SERVICE wikibase:label {
        bd:serviceParam wikibase:language "ko,en" .
    }
}
ORDER BY DESC(?population)
LIMIT 20
        </pre>
    </div>
</section>

<!-- 섹션 7.8: SPARQL Update -->
<section class="content-section">
    <h2>7.8 SPARQL Update - 데이터 조작</h2>
    
    <div class="update-intro">
        <h3>🔄 읽기를 넘어 쓰기로</h3>
        <p>SPARQL 1.1 Update는 RDF 데이터를 삽입, 수정, 삭제할 수 있는 강력한 기능입니다.</p>
    </div>

    <div class="update-operations">
        <h3>🛠️ Update 연산자</h3>
        
        <div class="operation-grid">
            <div class="operation-card">
                <h4>INSERT DATA</h4>
                <p>새로운 트리플 직접 추가</p>
                <pre><code>INSERT DATA {
    ex:John foaf:name "John Smith" ;
            foaf:age 30 ;
            ex:worksAt ex:CompanyA .
}</code></pre>
            </div>
            
            <div class="operation-card">
                <h4>DELETE DATA</h4>
                <p>특정 트리플 삭제</p>
                <pre><code>DELETE DATA {
    ex:John foaf:age 30 .
}</code></pre>
            </div>
            
            <div class="operation-card">
                <h4>DELETE/INSERT WHERE</h4>
                <p>패턴 기반 수정</p>
                <pre><code>DELETE { ?person foaf:age ?oldAge }
INSERT { ?person foaf:age ?newAge }
WHERE {
    ?person foaf:name "John Smith" ;
            foaf:age ?oldAge .
    BIND(?oldAge + 1 AS ?newAge)
}</code></pre>
            </div>
            
            <div class="operation-card">
                <h4>CLEAR/DROP</h4>
                <p>그래프 전체 삭제</p>
                <pre><code># 특정 그래프 비우기
CLEAR GRAPH ex:tempData

# 그래프 자체 삭제
DROP GRAPH ex:tempData</code></pre>
            </div>
        </div>
    </div>

    <div class="update-examples">
        <h3>🎯 실전 Update 예제</h3>
        
        <div class="update-example">
            <h4>예제 1: 대량 데이터 업데이트</h4>
            <pre><code class="language-sparql"># 모든 제품의 가격 10% 인상
DELETE {
    ?product ex:price ?oldPrice .
}
INSERT {
    ?product ex:price ?newPrice ;
             ex:lastUpdated ?now .
}
WHERE {
    ?product a ex:Product ;
             ex:price ?oldPrice .
    
    BIND(?oldPrice * 1.1 AS ?newPrice)
    BIND(now() AS ?now)
}</code></pre>
        </div>
        
        <div class="update-example">
            <h4>예제 2: 조건부 데이터 삽입</h4>
            <pre><code class="language-sparql"># 특정 조건을 만족하는 사용자에게 배지 부여
INSERT {
    ?user ex:hasBadge ex:ActiveContributor ;
          ex:badgeAwardedDate ?today .
}
WHERE {
    ?user a foaf:Person .
    
    # 최근 30일간 10개 이상의 기여
    {
        SELECT ?user (COUNT(?contrib) AS ?contribCount)
        WHERE {
            ?contrib ex:contributor ?user ;
                    ex:date ?date .
            FILTER(?date > now() - "P30D"^^xsd:duration)
        }
        GROUP BY ?user
        HAVING(?contribCount >= 10)
    }
    
    # 아직 배지가 없는 경우만
    FILTER NOT EXISTS {
        ?user ex:hasBadge ex:ActiveContributor .
    }
    
    BIND(now() AS ?today)
}</code></pre>
        </div>
        
        <div class="update-example">
            <h4>예제 3: 데이터 마이그레이션</h4>
            <pre><code class="language-sparql"># 오래된 스키마에서 새 스키마로 이전
DELETE {
    GRAPH ex:oldSchema {
        ?s ?p ?o .
    }
}
INSERT {
    GRAPH ex:newSchema {
        ?s ?newP ?o .
    }
}
WHERE {
    GRAPH ex:oldSchema {
        ?s ?p ?o .
    }
    
    # 속성 매핑
    VALUES (?p ?newP) {
        (ex:firstName foaf:givenName)
        (ex:lastName foaf:familyName)
        (ex:email foaf:mbox)
    }
}</code></pre>
        </div>
    </div>

    <div class="transaction-management">
        <h3>🔒 트랜잭션 관리</h3>
        <div class="transaction-example">
            <pre><code class="language-sparql"># 여러 업데이트를 하나의 트랜잭션으로
BEGIN;

# 1. 사용자 생성
INSERT DATA {
    ex:user123 a foaf:Person ;
               foaf:name "Alice Kim" ;
               ex:registrationDate "2024-01-15"^^xsd:date .
};

# 2. 기본 설정 추가
INSERT DATA {
    ex:user123 ex:preferences [
        ex:language "ko" ;
        ex:timezone "Asia/Seoul" ;
        ex:notifications true
    ] .
};

# 3. 환영 메시지 기록
INSERT DATA {
    ex:welcomeMsg123 a ex:SystemMessage ;
                     ex:recipient ex:user123 ;
                     ex:content "Welcome to our platform!" ;
                     ex:sentDate "2024-01-15"^^xsd:date .
};

COMMIT;</code></pre>
        </div>
    </div>
</section>

<!-- 섹션 7.9: 성능 최적화와 베스트 프랙티스 -->
<section class="content-section">
    <h2>7.9 SPARQL 성능 최적화</h2>
    
    <div class="optimization-intro">
        <h3>⚡ 빠른 쿼리의 비밀</h3>
        <p>대규모 RDF 데이터에서 효율적인 SPARQL 쿼리를 작성하는 방법을 알아봅니다.</p>
    </div>

    <div class="optimization-strategies">
        <h3>🎯 최적화 전략</h3>
        
        <div class="strategy-grid">
            <div class="strategy-card">
                <h4>1. 선택적 패턴 배치</h4>
                <div class="bad-example">
                    <h5>❌ 비효율적</h5>
                    <pre><code>SELECT ?person ?name
WHERE {
    ?person ?p ?o .  # 모든 트리플
    ?person foaf:name ?name .
    ?person a foaf:Person .
}</code></pre>
                </div>
                <div class="good-example">
                    <h5>✅ 효율적</h5>
                    <pre><code>SELECT ?person ?name
WHERE {
    ?person a foaf:Person .  # 가장 선택적
    ?person foaf:name ?name .
}</code></pre>
                </div>
            </div>
            
            <div class="strategy-card">
                <h4>2. FILTER 최적화</h4>
                <div class="bad-example">
                    <h5>❌ 비효율적</h5>
                    <pre><code>SELECT ?product ?price
WHERE {
    ?product ex:price ?price .
    FILTER(str(?price) = "100")
}</code></pre>
                </div>
                <div class="good-example">
                    <h5>✅ 효율적</h5>
                    <pre><code>SELECT ?product ?price
WHERE {
    ?product ex:price 100 .  # 직접 매칭
    BIND(100 AS ?price)
}</code></pre>
                </div>
            </div>
            
            <div class="strategy-card">
                <h4>3. 서브쿼리 활용</h4>
                <pre><code># 복잡한 집계를 서브쿼리로 분리
SELECT ?category ?avgPrice ?productCount
WHERE {
    {
        SELECT ?category 
               (AVG(?price) AS ?avgPrice)
               (COUNT(?product) AS ?productCount)
        WHERE {
            ?product ex:category ?category ;
                    ex:price ?price ;
                    ex:available true .
        }
        GROUP BY ?category
        HAVING(?productCount > 10)
    }
    
    FILTER(?avgPrice < 1000)
}
ORDER BY DESC(?productCount)</code></pre>
            </div>
            
            <div class="strategy-card">
                <h4>4. 인덱스 활용</h4>
                <ul>
                    <li>URI 기반 인덱스 사용</li>
                    <li>리터럴 인덱스 구성</li>
                    <li>자주 사용되는 패턴 캐싱</li>
                    <li>통계 기반 쿼리 플래너</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="query-hints">
        <h3>💡 쿼리 힌트와 프로파일링</h3>
        <pre><code class="language-sparql"># 쿼리 플래너 힌트 사용
SELECT ?person ?name
WHERE {
    # Virtuoso 힌트
    # HINT: INDEX_USE=primary
    ?person a foaf:Person ;
            foaf:name ?name ;
            ex:age ?age .
    
    FILTER(?age > 18)
}

# EXPLAIN으로 쿼리 플랰 확인
EXPLAIN SELECT ...</code></pre>
    </div>
</section>

<!-- 섹션 7.10: 실전 프로젝트 -->
<section class="content-section">
    <h2>7.10 실전 SPARQL 프로젝트</h2>
    
    <div class="project-intro">
        <h3>🎯 종합 프로젝트: 지식 그래프 기반 추천 시스템</h3>
        <p>영화 추천 시스템을 SPARQL로 구현해보며 실전 감각을 익힙니다.</p>
    </div>

    <div class="project-implementation">
        <h4>프로젝트 구현</h4>
        
        <div class="implementation-step">
            <h5>1. 데이터 모델링</h5>
            <pre><code class="language-turtle"># 영화 온톨로지
@prefix movie: <http://example.org/movie/> .
@prefix schema: <http://schema.org/> .

movie:Inception a schema:Movie ;
    schema:name "Inception" ;
    schema:director movie:ChristopherNolan ;
    schema:genre "Sci-Fi", "Thriller" ;
    schema:actor movie:LeonardoDiCaprio ;
    schema:datePublished "2010"^^xsd:gYear ;
    schema:aggregateRating 8.8 .

movie:user123 a schema:Person ;
    schema:name "John" ;
    movie:watched movie:Inception ;
    movie:rating [ 
        schema:ratingValue 9 ;
        schema:itemRated movie:Inception 
    ] .</code></pre>
        </div>
        
        <div class="implementation-step">
            <h5>2. 추천 쿼리</h5>
            <pre><code class="language-sparql"># 협업 필터링 기반 추천
SELECT ?movie ?title ?score
WHERE {
    # 사용자가 본 영화
    movie:user123 movie:watched ?watchedMovie .
    
    # 같은 감독/배우의 다른 영화
    {
        ?watchedMovie schema:director ?director .
        ?movie schema:director ?director .
    }
    UNION
    {
        ?watchedMovie schema:actor ?actor .
        ?movie schema:actor ?actor .
    }
    
    # 기본 정보
    ?movie schema:name ?title ;
           schema:aggregateRating ?rating .
    
    # 이미 본 영화 제외
    FILTER(?movie != ?watchedMovie)
    FILTER NOT EXISTS {
        movie:user123 movie:watched ?movie .
    }
    
    # 유사도 점수 계산
    {
        SELECT ?movie (COUNT(*) AS ?connections)
        WHERE {
            movie:user123 movie:watched ?watched .
            {
                ?watched schema:director ?d .
                ?movie schema:director ?d .
            }
            UNION
            {
                ?watched schema:actor ?a .
                ?movie schema:actor ?a .
            }
            UNION
            {
                ?watched schema:genre ?g .
                ?movie schema:genre ?g .
            }
        }
        GROUP BY ?movie
    }
    
    BIND(?connections * 0.3 + ?rating * 0.7 AS ?score)
}
ORDER BY DESC(?score)
LIMIT 10</code></pre>
        </div>
        
        <div class="implementation-step">
            <h5>3. 트렌드 분석</h5>
            <pre><code class="language-sparql"># 인기 장르 분석
SELECT ?genre 
       (COUNT(?movie) AS ?movieCount)
       (AVG(?rating) AS ?avgRating)
       (COUNT(DISTINCT ?user) AS ?viewerCount)
WHERE {
    ?movie a schema:Movie ;
           schema:genre ?genre ;
           schema:aggregateRating ?rating .
    
    ?user movie:watched ?movie ;
          movie:watchDate ?date .
    
    # 최근 6개월 데이터
    FILTER(?date > now() - "P6M"^^xsd:duration)
}
GROUP BY ?genre
ORDER BY DESC(?viewerCount)</code></pre>
        </div>
    </div>
</section>

<!-- 핵심 정리 -->
<div class="summary-section">
    <h2>💡 핵심 정리</h2>
    
    <div class="summary-grid">
        <div class="summary-card">
            <h3>기본 구조</h3>
            <ul>
                <li>SELECT/WHERE 패턴</li>
                <li>트리플 패턴 매칭</li>
                <li>변수와 바인딩</li>
                <li>PREFIX 선언</li>
            </ul>
        </div>
        
        <div class="summary-card">
            <h3>고급 기능</h3>
            <ul>
                <li>FILTER와 함수</li>
                <li>OPTIONAL/UNION</li>
                <li>집계와 GROUP BY</li>
                <li>서브쿼리</li>
            </ul>
        </div>
        
        <div class="summary-card">
            <h3>실전 활용</h3>
            <ul>
                <li>복잡한 그래프 순회</li>
                <li>페더레이션 질의</li>
                <li>업데이트 연산</li>
                <li>성능 최적화</li>
            </ul>
        </div>
    </div>
</div>

<!-- 실습 과제 -->
<div class="practice-section">
    <h2>🎯 실습 과제</h2>
    
    <div class="practice-task">
        <h3>과제 1: 도서 검색 시스템</h3>
        <p>다음 기능을 구현하는 SPARQL 질의를 작성하세요:</p>
        <ol>
            <li>특정 저자의 모든 책 조회</li>
            <li>2020년 이후 출판된 책 중 평점 4.0 이상</li>
            <li>장르별 도서 수와 평균 가격</li>
            <li>가장 많은 책을 쓴 저자 Top 5</li>
        </ol>
    </div>
    
    <div class="practice-task">
        <h3>과제 2: 소셜 네트워크 분석</h3>
        <p>친구 관계 그래프에서:</p>
        <ol>
            <li>특정 사람의 친구의 친구 찾기</li>
            <li>공통 친구가 가장 많은 사람들</li>
            <li>친구가 없는 사람 찾기</li>
        </ol>
    </div>
</div>

<!-- 학습 완료 체크리스트 -->
<div class="completion-checklist">
    <h2>🏁 학습 완료 체크리스트</h2>
    <p>아래 항목들을 모두 이해하고 실습해보셨나요?</p>
    
    <div class="checklist-columns">
        <div class="checklist-column">
            <h4>기본 개념</h4>
            <label><input type="checkbox"> SPARQL의 탄생 배경과 철학 이해</label>
            <label><input type="checkbox"> 4가지 쿼리 형식(SELECT, CONSTRUCT, ASK, DESCRIBE) 숨용</label>
            <label><input type="checkbox"> 트리플 패턴 매칭의 원리 이해</label>
            <label><input type="checkbox"> PREFIX와 네임스페이스 활용</label>
        </div>
        
        <div class="checklist-column">
            <h4>중급 기능</h4>
            <label><input type="checkbox"> FILTER 함수와 조건식 작성</label>
            <label><input type="checkbox"> OPTIONAL, UNION, MINUS 패턴 활용</label>
            <label><input type="checkbox"> 집계 함수와 GROUP BY 사용</label>
            <label><input type="checkbox"> 서브쿼리와 BIND 활용</label>
        </div>
        
        <div class="checklist-column">
            <h4>고급 기능</h4>
            <label><input type="checkbox"> Property Path로 복잡한 그래프 탐색</label>
            <label><input type="checkbox"> Federated Query로 여러 데이터 소스 통합</label>
            <label><input type="checkbox"> SPARQL Update로 데이터 조작</label>
            <label><input type="checkbox"> 쿼리 성능 최적화 기법 적용</label>
        </div>
    </div>
    
    <div class="completion-score">
        <p>체크한 항목: <span id="checked-count">0</span>/12</p>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>
</div>

<!-- 실습 과제 -->
<div class="practice-exercises">
    <h2>📝 실습 과제</h2>
    
    <div class="exercise-card">
        <h3>과제 1: 기본 SPARQL 쿼리</h3>
        <p>DBpedia에서 한국의 도시 정보를 조회하는 SPARQL 쿼리를 작성하세요.</p>
        <ul>
            <li>도시 이름, 인구, 면적 조회</li>
            <li>인구 100만 이상의 도시만 필터링</li>
            <li>인구 순으로 정렬</li>
        </ul>
    </div>
    
    <div class="exercise-card">
        <h3>과제 2: 복잡한 패턴 매칭</h3>
        <p>소셜 네트워크에서 3촌 이내의 모든 연결을 찾는 쿼리를 작성하세요.</p>
        <ul>
            <li>Property Path 사용</li>
            <li>각 경로의 길이 계산</li>
            <li>중복 경로 제거</li>
        </ul>
    </div>
    
    <div class="exercise-card">
        <h3>과제 3: 데이터 분석</h3>
        <p>제품 판매 데이터를 분석하는 SPARQL 쿼리를 작성하세요.</p>
        <ul>
            <li>카테고리별 평균 가격과 판매량</li>
            <li>월별 판매 추이</li>
            <li>상위 10% 고객 분석</li>
        </ul>
    </div>
</div>

<!-- 추가 학습 자료 -->
<div class="additional-resources">
    <h2>📚 추가 학습 자료</h2>
    
    <div class="resource-grid">
        <div class="resource-card">
            <h4>🌐 온라인 리소스</h4>
            <ul>
                <li><a href="https://www.w3.org/TR/sparql11-query/">W3C SPARQL 1.1 공식 스펙</a></li>
                <li><a href="https://query.wikidata.org/">Wikidata Query Service</a></li>
                <li><a href="http://dbpedia.org/sparql">DBpedia SPARQL Endpoint</a></li>
                <li><a href="https://yasgui.triply.cc/">YASGUI - SPARQL 에디터</a></li>
            </ul>
        </div>
        
        <div class="resource-card">
            <h4>📖 추천 도서</h4>
            <ul>
                <li>"Learning SPARQL" - Bob DuCharme</li>
                <li>"Semantic Web for the Working Ontologist" - Allemang & Hendler</li>
                <li>"Practical RDF" - Shelley Powers</li>
            </ul>
        </div>
        
        <div class="resource-card">
            <h4>💻 실습 환경</h4>
            <ul>
                <li>Apache Jena Fuseki</li>
                <li>Virtuoso Open Source</li>
                <li>GraphDB Free</li>
                <li>Blazegraph</li>
            </ul>
        </div>
    </div>
</div>

<!-- 다음 장 예고 -->
<div class="next-chapter">
    <h3>다음 장에서는...</h3>
    <p>온톨로지 추론과 추론 엔진에 대해 학습합니다. OWL의 추론 규칙과 실제 추론 엔진 활용법을 알아봅니다.</p>
    <button class="next-btn" onclick="OntologyBook.loadChapter('chapter08')">
        다음 장으로 <i class="fas fa-arrow-right"></i>
    </button>
</div>

<!-- 챕터 전용 스타일 -->
<style>
/* 비교 테이블 */
.comparison-table {
    margin: 2rem 0;
    overflow-x: auto;
}

.comparison-table table {
    width: 100%;
    border-collapse: collapse;
    background: white;
    border-radius: 12px;
    overflow: hidden;
}

.comparison-table th {
    background: #4f46e5;
    color: white;
    padding: 1rem;
    text-align: left;
}

.comparison-table td {
    padding: 1rem;
    border-bottom: 1px solid #e5e7eb;
}

/* 질의 구조 */
.query-structure {
    background: #f8fafc;
    padding: 2rem;
    border-radius: 12px;
    margin: 2rem 0;
}

.query-structure pre {
    font-size: 1.1rem;
    color: #1e293b;
}

/* SPARQL 코드 */
.sparql-code {
    background: #1e293b;
    color: #e2e8f0;
    padding: 1.5rem;
    border-radius: 8px;
    overflow-x: auto;
    font-family: 'Courier New', monospace;
    line-height: 1.6;
    margin: 1rem 0;
}

.sparql-code:hover {
    background: #0f172a;
}

/* 질의 타입 카드 */
.query-types {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.query-type-card {
    background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
    padding: 1.5rem;
    border-radius: 12px;
    text-align: center;
    transition: transform 0.3s;
}

.query-type-card:hover {
    transform: translateY(-4px);
}

.query-type-card h4 {
    color: #4c1d95;
    font-family: 'Courier New', monospace;
    font-size: 1.3rem;
    margin-bottom: 0.5rem;
}

.query-type-card .usage {
    background: white;
    padding: 0.5rem;
    border-radius: 6px;
    margin-top: 1rem;
    font-size: 0.9rem;
    color: #64748b;
}

/* 패턴 다이어그램 */
.graph-pattern {
    background: white;
    padding: 2rem;
    border-radius: 12px;
    border: 2px solid #e5e7eb;
    margin: 1.5rem 0;
    font-family: 'Courier New', monospace;
    text-align: center;
}

.graph-pattern .node {
    display: inline-block;
    background: #f0f9ff;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    border: 2px solid #0ea5e9;
    margin: 0.5rem;
}

.graph-pattern .node.person {
    background: #fef3c7;
    border-color: #f59e0b;
}

.graph-pattern .node.company {
    background: #dcfce7;
    border-color: #22c55e;
}

.graph-pattern .edge {
    display: inline-block;
    color: #64748b;
    margin: 0 0.5rem;
}

/* 필터 카드 */
.filter-examples {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.filter-card {
    background: white;
    padding: 1.5rem;
    border-radius: 12px;
    border: 2px solid #e5e7eb;
}

.filter-card h4 {
    color: #1e293b;
    margin-bottom: 1rem;
}

/* 함수 카테고리 */
.built-in-functions {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.function-category {
    background: #f0f9ff;
    padding: 1.5rem;
    border-radius: 12px;
}

.function-category h4 {
    color: #0369a1;
    margin-bottom: 1rem;
}

.function-category ul {
    list-style: none;
    padding: 0;
}

.function-category li {
    padding: 0.3rem 0;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

/* 패턴 예제 */
.optional-pattern,
.union-pattern,
.not-exists-pattern {
    background: #f8fafc;
    padding: 2rem;
    border-radius: 12px;
    margin: 1.5rem 0;
}

.explanation {
    color: #64748b;
    font-style: italic;
    margin-top: 1rem;
    padding: 1rem;
    background: white;
    border-radius: 8px;
}

/* 집계 예제 */
.aggregation-functions {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.agg-example {
    background: white;
    padding: 1.5rem;
    border-radius: 12px;
    border: 2px solid #fbbf24;
}

.agg-example h4 {
    color: #92400e;
    margin-bottom: 1rem;
}

/* 엔드포인트 카드 */
.endpoint-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.endpoint-card {
    background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
    padding: 1.5rem;
    border-radius: 12px;
    text-align: center;
}

.endpoint-card h4 {
    color: #1e40af;
    margin-bottom: 0.5rem;
}

.endpoint-url {
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    color: #2563eb;
    word-break: break-all;
    margin: 0.5rem 0;
}

/* 복잡한 질의 예제 */
.complex-query-example,
.federation-example,
.wikidata-example,
.update-example,
.grouping-example,
.ordering-examples,
.paging-example {
    background: #f8fafc;
    padding: 2rem;
    border-radius: 16px;
    margin: 2rem 0;
}

.complex-query-example h4,
.federation-example h4,
.wikidata-example h4 {
    color: #1e293b;
    margin-bottom: 1rem;
}

/* 변수 예제 */
.variable-constant {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.var-const-example {
    background: white;
    padding: 1.5rem;
    border-radius: 12px;
    border: 2px solid #e5e7eb;
}

.var-const-example h4 {
    color: #1e293b;
    margin-bottom: 1rem;
}

/* 복잡한 패턴 */
.complex-patterns {
    margin: 2rem 0;
}

.complex-patterns h4 {
    color: #1e293b;
    margin-bottom: 1rem;
}

/* 첫 번째 쿼리 */
.first-query {
    background: #f8fafc;
    padding: 2rem;
    border-radius: 12px;
    margin: 2rem 0;
}

.first-query h4 {
    color: #1e293b;
    margin-bottom: 1rem;
}

.query-explanation {
    background: white;
    padding: 1.5rem;
    border-radius: 8px;
    margin-top: 1rem;
}

.query-explanation ul {
    margin-top: 0.5rem;
}

.query-explanation code {
    background: #e2e8f0;
    padding: 0.2rem 0.4rem;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
}

/* 코드 블록 */
.code-block {
    background: #1e293b;
    color: #f1f5f9;
    padding: 1.5rem;
    border-radius: 8px;
    overflow-x: auto;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    line-height: 1.6;
    margin: 1rem 0;
}

/* 반응형 디자인 */
@media (max-width: 768px) {
    .query-types,
    .filter-examples,
    .built-in-functions,
    .aggregation-functions,
    .endpoint-list {
        grid-template-columns: 1fr;
    }
    
    .sparql-code {
        font-size: 0.8rem;
        padding: 1rem;
    }
}
</style>