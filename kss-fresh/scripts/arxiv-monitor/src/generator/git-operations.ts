/**
 * Git Operations
 * Handles Git commits for generated MDX files
 */

import simpleGit, { SimpleGit } from 'simple-git'
import path from 'path'
import logger from '../utils/logger'
import { config } from '../utils/config'

// Initialize git instance
const git: SimpleGit = simpleGit({
  baseDir: path.join(__dirname, '../../../../'), // kss-fresh root
  binary: 'git',
  maxConcurrentProcesses: 6,
})

/**
 * Check if file exists and is tracked by Git
 */
export async function isFileTracked(filePath: string): Promise<boolean> {
  try {
    const status = await git.status([filePath])
    return status.files.length > 0
  } catch (error) {
    return false
  }
}

/**
 * Add file to Git staging area
 */
export async function addFile(filePath: string): Promise<void> {
  try {
    await git.add(filePath)
    logger.debug(`Added file to git: ${filePath}`)
  } catch (error) {
    logger.error(`Failed to add file to git: ${filePath}`, { error })
    throw error
  }
}

/**
 * Commit changes with message
 */
export async function commit(message: string): Promise<string> {
  try {
    const result = await git.commit(message)
    logger.info('Git commit successful', {
      commit: result.commit,
      summary: result.summary,
    })
    return result.commit
  } catch (error) {
    logger.error('Failed to commit changes', { error })
    throw error
  }
}

/**
 * Push changes to remote
 */
export async function push(branch: string = config.GITHUB_BRANCH): Promise<void> {
  try {
    await git.push('origin', branch)
    logger.info(`Pushed changes to origin/${branch}`)
  } catch (error) {
    logger.error(`Failed to push to origin/${branch}`, { error })
    throw error
  }
}

/**
 * Get current branch name
 */
export async function getCurrentBranch(): Promise<string> {
  try {
    const branch = await git.revparse(['--abbrev-ref', 'HEAD'])
    return branch.trim()
  } catch (error) {
    logger.error('Failed to get current branch', { error })
    throw error
  }
}

/**
 * Check if there are uncommitted changes
 */
export async function hasUncommittedChanges(): Promise<boolean> {
  try {
    const status = await git.status()
    return status.files.length > 0
  } catch (error) {
    logger.error('Failed to check git status', { error })
    return false
  }
}

/**
 * Generate commit message for new papers
 */
export function generateCommitMessage(paperCount: number, arxivIds: string[]): string {
  const idsStr = arxivIds.slice(0, 3).join(', ')
  const moreCount = paperCount > 3 ? ` and ${paperCount - 3} more` : ''

  return `ðŸ“š Add ${paperCount} new AI paper${paperCount > 1 ? 's' : ''} from ArXiv

Papers:
${arxivIds.map((id) => `- ${id}`).join('\n')}

Auto-generated by KSS ArXiv Monitor
Date: ${new Date().toISOString().split('T')[0]}`
}

/**
 * Create and commit MDX file
 */
export async function commitMDXFile(
  filePath: string,
  arxivId: string
): Promise<boolean> {
  try {
    // Add file
    await addFile(filePath)

    // Create commit message
    const message = `ðŸ“„ Add paper ${arxivId}

Auto-generated by KSS ArXiv Monitor`

    // Commit
    await commit(message)

    logger.info(`Committed MDX file: ${filePath}`)
    return true
  } catch (error) {
    logger.error(`Failed to commit MDX file: ${filePath}`, { error })
    return false
  }
}

/**
 * Batch commit multiple papers
 */
export async function batchCommitPapers(
  filePaths: string[],
  arxivIds: string[]
): Promise<boolean> {
  try {
    // Add all files
    for (const filePath of filePaths) {
      await addFile(filePath)
    }

    // Create batch commit message
    const message = generateCommitMessage(arxivIds.length, arxivIds)

    // Commit
    await commit(message)

    logger.info(`Batch committed ${filePaths.length} MDX files`)
    return true
  } catch (error) {
    logger.error('Failed to batch commit papers', { error })
    return false
  }
}

/**
 * Validate Git configuration
 */
export async function validateGitConfig(): Promise<boolean> {
  try {
    // Check if we're in a git repository
    const isRepo = await git.checkIsRepo()
    if (!isRepo) {
      logger.error('Not a git repository')
      return false
    }

    // Check git user config
    const userName = await git.getConfig('user.name')
    const userEmail = await git.getConfig('user.email')

    if (!userName.value || !userEmail.value) {
      logger.error('Git user.name or user.email not configured')
      return false
    }

    logger.debug('Git configuration validated', {
      userName: userName.value,
      userEmail: userEmail.value,
    })

    return true
  } catch (error) {
    logger.error('Failed to validate git configuration', { error })
    return false
  }
}
